//------------------------------------------------------------------------------
// Matching debug-info nodes and LLVM entities
//------------------------------------------------------------------------------

// Matching predicates

di:match_variable(Var, DIVar) ->
   variable(Var), di:variable(DIVar).

di:match_global_variable[DIVar] = Var ->
   global_variable(Var), di:variable(DIVar).

di:match_type[DIType] = Type ->
   type(Type), di:type_entry(DIType).

type:di_entry[Type] = DIType ->
   type(Type), di:type_entry(DIType).


//------------------------------------------------------------------------------
// Matching variables to debug-info nodes
//------------------------------------------------------------------------------

// Match global variables
di:match_global_variable[DIVar] = Var <-
   di:global_variable:resolved_name[DIVar] = Name,
   global_variable:by_name[Name] = Var.


// Match local variables
di:match_variable(Var, DIVar) <-
   di:local_variable_declaration(DIVar, Var).


// Match function parameters
di:match_variable(Param, DIParam) <-
   di:local_variable:is_parameter(DIParam),
   di:local_variable:arg_num[DIParam] = Index,
   di:variable:scope[DIParam] = DIScope,
   di:subprogram:function[DIScope] = Func,
   function:param[Func, Index - 1] = Param.


//------------------------------------------------------------------------------
// Matching types to debug-info nodes
//------------------------------------------------------------------------------

// Match global variable types
_di_possible_match_type(Type, DIType) <-
   di:match_global_variable[DIVar] = Var,
   di:variable:type[DIVar] = DIType,
   global_variable:type[Var] = Type.

// Match local variable types
_di_possible_match_type(Type, DIType) <-
   di:match_variable(Var, DIVar),
   di:variable:type[DIVar] = DIType,
   variable:type[Var] = Type.

// Match after `unconsting`
_di_possible_match_type(Type, DIType) <-
   _di_possible_match_type(Type, DIConstType),
   di:const_type_entry(DIConstType),
   di:derived_type_base[DIConstType] = DIType.

// Match component of pointer types
_di_possible_match_type(CompType, DICompType) <-
   _di_possible_match_type(PtrType, DIPtrType),
   di:ptr_type_entry(DIPtrType),
   di:derived_type_base[DIPtrType] = DICompType,
   pointer_type:component[PtrType] = CompType.

// Match component of reference types
_di_possible_match_type(CompType, DICompType) <-
   _di_possible_match_type(PtrType, DIRefType),
   di:reference_type_entry(DIRefType),
   di:derived_type_base[DIRefType] = DICompType,
   pointer_type:component[PtrType] = CompType.

// Match component of array types
_di_possible_match_type(CompType, DICompType) <-
   _di_possible_match_type(ArrayType, DIArrayType),
   di:array_type_entry(DIArrayType),
   di:array_type_base[DIArrayType] = DICompType,
   array_type:component[ArrayType] = CompType.

// Match typedef'd types
_di_possible_match_type(Type, DITypedefdType) <-
   _di_possible_match_type(Type, DIType),
   typedefd_type[DIType, _] = DITypedefdType.

_di_possible_match_type(Type, DIType) <-
   _di_possible_match_type(Type, DITypedefdType),
   typedefd_type[DIType, _] = DITypedefdType.


//---------------------------------------------------------------
// Compute matching types, by name only
//---------------------------------------------------------------

// Simple type matching filters
_aggregate_type_by_stripped_name(StrippedName, Type) <-
   aggregate_type(Type), !array_type(Type),
   type:id(Type:TypeID),
   string:split[TypeID, ".", 1] = StrippedName.

_di_match_types_by_name(DIType, Type) <-
   di:composite_type_entry(DIType),
   di_template_type:stripped_name[DIType] = StrippedName,
   _aggregate_type_by_stripped_name(StrippedName, Type).

_di_match_types_by_name(DIType, Type) <-
   di:composite_type_entry(DIType), !di_template_type(DIType),
   di:type_entry:to_string[DIType] = ScopedName,
   _aggregate_type_by_stripped_name(ScopedName, Type).

_di_match_types_by_name_and_size(DIType, Type) <-
   di:type_entry:bit_size[DIType] = BitSize,
   type:size[Type] = ByteSize,
   type:unpadded_size[Type] = UnpaddedByteSize,
   ( BitSize = 8 * ByteSize
   ; BitSize = 8 * UnpaddedByteSize
   ; !di_template_type(DIType)),
   _di_match_types_by_name(DIType, Type).

// Inverted Indices
_di_match_types_by_name_inv__(Type, DIType) <-
   _di_match_types_by_name(DIType, Type).

_di_match_types_by_name_and_size_inv__(Type, DIType) <-
   _di_match_types_by_name_and_size(DIType, Type).

// No resolution yet
_multiple_types_by_name(DIType) <-
   _di_match_types_by_name_inv__(Type1, DIType),
   _di_match_types_by_name_inv__(Type2, DIType),
   Type1 != Type2.

_multiple_di_types_by_name(Type) <-
   _di_match_types_by_name(DIType1, Type),
   _di_match_types_by_name(DIType2, Type),
   DIType1 != DIType2.

_multiple_types_by_name_and_size(DIType) <-
   _di_match_types_by_name_and_size_inv__(Type1, DIType),
   _di_match_types_by_name_and_size_inv__(Type2, DIType),
   Type1 != Type2.

_multiple_di_types_by_name_and_size(Type) <-
   _di_match_types_by_name_and_size(DIType1, Type),
   _di_match_types_by_name_and_size(DIType2, Type),
   DIType1 != DIType2.

// Resolved
type:di_entry[Type] = DIType <-
   _di_match_types_by_name(DIType, Type),
   !_multiple_di_types_by_name(Type).

type:di_entry[Type] = DIType <-
   _di_match_types_by_name_and_size(DIType, Type),
   !_multiple_di_types_by_name_and_size(Type).

di:match_type[DIType] = Type <-
   _di_match_types_by_name_inv__(Type, DIType),
   !_multiple_types_by_name(DIType).

di:match_type[DIType] = Type <-
   _di_match_types_by_name_and_size_inv__(Type, DIType),
   !_multiple_types_by_name_and_size(DIType).

// Match array types
di:match_type[DIArrayType] = ArrayType <-
   di:array_type_entry(DIArrayType),
   di:array_type_base[DIArrayType] = DICompType,
   di:match_type[DICompType] = CompType,
   array_type:component[ArrayType] = CompType,
   array_type:size[ArrayType] = Size,
   di:composite_type_entry:subrange[DIArrayType, 0] = DISubrange,
   di:subrange:count[DISubrange] = Size.

// Match after `unconsting`
di:match_type[DIConstType] = Type <-
   di:const_type_entry(DIConstType),
   di:derived_type_base[DIConstType] = DIType,
   di:match_type[DIType] = Type.

// Match pointer types
di:match_type[DIPtrType] = PtrType <-
   di:ptr_type_entry(DIPtrType),
   di:derived_type_base[DIPtrType] = DICompType,
   di:match_type[DICompType] = CompType,
   pointer_type:component[PtrType] = CompType.

// Match reference types
di:match_type[DIRefType] = PtrType <-
   di:reference_type_entry(DIRefType),
   di:derived_type_base[DIRefType] = DICompType,
   di:match_type[DICompType] = CompType,
   pointer_type:component[PtrType] = CompType.

// Match typedef'd types
di:match_type[DITypeAlias] = Type <-
   typedefd_type[DITypeAlias, _] = DIType,
   di:match_type[DIType] = Type.


//------------------------------------------------------------------------------
// [Compute field names and inheritance, by offset]
//
// Note that a union type may have two different field names at the
// same offset. Hence, the debuginfo FIELD-NAME-AT-OFFSET relation
// cannot be declared functional.
//
// Also, a struct/class type may inherit multiple types at offset 0,
// if all but one of them are of zero size. Hence, neither the
// debuginfo INHERITS-AT-OFFSET relation can be declared functional.
//------------------------------------------------------------------------------

// Bypass typedefs

_true_type[DIType] = DITrueType <-
   typedefd_type[DIType, _] = DITrueType,
   !typedefd_type[DITrueType, _] = _.

_true_type[DIType] = DITrueType <-
   typedefd_type[DIType, _] = DIAnotherType,
   _true_type[DIAnotherType] = DITrueType.

_true_type_or_self[DIType] = DITrueType <-
   _true_type[DIType] = DITrueType.

_true_type_or_self[DIType] = DIType <-
   di:composite_type_entry(DIType),
   !typedefd_type[DIType, _] = _.

// Field Names

_di_field_name_at_offset(DIType, Offset, FieldName) <-
   di:type:field_name[DIType, Index] = FieldName,
   di:type:field_offset[DIType, Index] = Offset,
   !di:type:static_field[DIType, Index] = _.

_type_field_conflict(Type, Offset) <-
   _di_match_types_by_name(DIType1, Type),
   _di_match_types_by_name(DIType2, Type),
   _di_field_name_at_offset(DIType1, Offset, FieldName1),
   _di_field_name_at_offset(DIType2, Offset, FieldName2),
   FieldName1 != FieldName2.

// TODO This should replace struct_type:field_name_at_offset
_field_name_at_offset[Type, Offset] = FieldName <-
   _di_match_types_by_name(DIType, Type),
   _di_field_name_at_offset(DIType, Offset, FieldName),
   !_type_field_conflict(Type, Offset).


// Inheritance

_di_inherits_at_offset(DIType, Offset, DIBaseType) <-
   di:type:inheritance_type[DIType, Index] = DIBaseType,
   di:type:inheritance_offset[DIType, Index] = Offset.

// TODO This should replace struct_type:inherits_at_offset$non_empty
_inherits_at_offset[Type, Offset] = BaseTypeName <-
   struct_type:field_bit_offset[Type, Index] = Offset,
   struct_type:field[Type, Index] = FieldType,
   struct_type(FieldType),
   _di_match_types_by_name_and_size(DIType, Type),
   _di_match_types_by_name_and_size(DIBaseType, FieldType),
   _di_inherits_at_offset(DIType, Offset, DIBaseType),
   !di_template_type(DIBaseType),
   di:type_entry:to_string[DIBaseType] = BaseTypeName.

_inherits_at_offset[Type, Offset] = StrippedBaseTypeName <-
   struct_type:field_bit_offset[Type, Index] = Offset,
   struct_type:field[Type, Index] = FieldType,
   struct_type(FieldType),
   _di_match_types_by_name_and_size(DIType, Type),
   _di_match_types_by_name_and_size(DIBaseType, FieldType),
   _di_inherits_at_offset(DIType, Offset, DIBaseType),
   di_template_type:stripped_name[DIBaseType] = StrippedBaseTypeName.
