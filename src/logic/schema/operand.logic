//------------
// Variables
//------------

variable(Var), variable:id(Var:Ref) -> string(Ref).

lang:physical:capacity[`variable] = 8388608.

variable:type[Var] = Type -> variable(Var), type(Type).

variable:label(Var) <-
   variable:type[Var] = Type,
   label_type[] = Type.

variable:pointer(Var) <-
   variable:type[Var] = Type,
   pointer_type(Type).

variable:firstclass(Var) <-
   variable:type[Var] = Type,
   type:firstclass(Type).


//--------------
// Constants
//--------------

constant(C), constant:id(C:Ref) -> string(Ref).

lang:physical:capacity[`constant] = 8388608.

constant:type[C] = Type -> constant(C), type(Type).
constant:value[C] = Val -> constant(C), string(Val).


// Auxiliary predicate that computes the last colon position of the
// constant's refmode

constant:last_colon_pos[C] = Pos ->
   constant(C), uint[32](Pos).

constant:last_colon_pos[C] = Pos  <-
   agg<<Pos = max(P)>> constant:id(C:Ref), string:substring[Ref, P, 1] = ":".


// Compute the actual value of the constant, since the refmode
// includes more fields in order to uniquely identify this constant
// from others that happen to have the exact same value.

constant:value[C] = Val <-
   constant:id(C:Ref),
   constant:last_colon_pos[C] = ColonPos,
   string:length[Ref] = Len,
   string:substring[Ref, ColonPos + 1, Len - ColonPos - 1] = Val.


// Auxiliary Predicates

constant:eq(C1, C2) <-
   constant:value[C1] = Val1,
   constant:value[C2] = Val2,
   Val1 = Val2. // is this enough??

constant:ne(C1, C2) <-
   constant(C1),
   constant(C2),
   !constant:eq(C1, C2).

lang:derivationType[`constant:ne] = "Derived".

// constants cannot be labels
schema:sanity()
 , constant:type[_] = type
 ->
   label_type[] != type.



//--------------------------------------------------
// [Operands] as union of {variable, constant}
//--------------------------------------------------

operand(Operand) -> .

lang:physical:capacity[`operand] = 8388608.

// Constructors
operand:by_variable[Var] = Operand  ->
   variable(Var), operand(Operand).

operand:by_constant[C] = Operand ->
   constant(C), operand(Operand).

lang:physical:storageModel[`operand] = "ScalableSparse".
lang:constructor(`operand:by_variable).
lang:constructor(`operand:by_constant).


// Type predicate
operand:type[Operand] = Type <-
   operand:by_variable[Var] = Operand,
   variable:type[Var] = Type.

operand:type[Operand] = Type <-
   operand:by_constant[C] = Operand,
   constant:type[C] = Type.


// View predicates
operand:as_variable[Operand] = Var <-
   operand:by_variable[Var] = Operand.

operand:as_constant[Operand] = C <-
   operand:by_constant[C] = Operand.

// Auxiliary functions
operand:pointer(Operand) <-
   operand:type[Operand] = Type,
   pointer_type(Type).

operand:firstclass(Var) <-
   operand:type[Var] = Type,
   type:firstclass(Type).


//----------------------------
//  Handy Conversions
//----------------------------

constant:to_int[Constant] = Value ->
   constant(Constant), int[64](Value).

operand:to_int[Operand] = Value ->
   operand(Operand), int[64](Value).

operand:to_int[Operand] = Value <-
   operand:by_constant[Constant] = Operand,
   constant:to_int[Constant] = Value.
