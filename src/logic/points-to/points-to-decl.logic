//-----------------------------------------------------------------------
// [Basic Concepts of Pointer Analysis]
//-----------------------------------------------------------------------

// The following relation tracks the flow of allocations to program
// variables. Named variables will point to their respective stack
// allocations.

var_points_to(ACtx, Alloc, Ctx, Var) ->
   alloc_context(ACtx), allocation(Alloc), context(Ctx), variable(Var).


// This is the equivalent relation that tracks flow of allocations
// among program constants. Note that references to global variables
// or functions are considered a type of constant in LLVM IR. Constant
// addresses are another type of constant that may point to
// memory. Moreover, a constant may be expanded to a larger complext
// constant (e.g., by a `bitcast` expression), through constant
// expressions.
//
// It is essential to be able to track the flow of allocations through
// all these types of constants, since an arbitrary complex constant
// expression may be used as an operand to a `store` or `load`
// instruction.

constant_points_to[Constant] = Alloc ->
   allocation(Alloc), constant(Constant).


// Intermediate relations

operand_points_to(ACtx, Alloc, Ctx, Operand) ->
   alloc_context(ACtx), allocation(Alloc), context(Ctx), operand(Operand).

operand_points_to(ACtx, Alloc, Ctx, VarOperand) <-
   operand:as_variable[VarOperand] = PtrVar,
   var_points_to(ACtx, Alloc, Ctx, PtrVar).

operand_points_to(ACtx, Alloc, Ctx, ConstantOperand) <-
   empty_alloc_context[] = ACtx,
   operand:as_constant[ConstantOperand] = Constant,
   operand:in_function[ConstantOperand] = EnclosingFunc,
   constant_points_to[Constant] = Alloc,
   reachable_context(Ctx, EnclosingFunc).

// Sanity checks
var_points_to(_, _, Ctx, Var)
 , variable:in_function[Var] = EnclosingFunc
 ->
   reachable_context(Ctx, EnclosingFunc).

operand_points_to(_, _, Ctx, Operand)
 , operand:in_function[Operand] = EnclosingFunc
 ->
   reachable_context(Ctx, EnclosingFunc).

//----------------------------
// Dereferencing Pointers
//----------------------------

// This is the traditional concept of `points-to`. It signifies that
// an allocation will point to another memory allocation when
// dereferenced.

ptr_points_to(ACtx, Alloc, PtrACtx, PtrAlloc) ->
   alloc_context(ACtx), allocation(Alloc),
   alloc_context(PtrACtx), allocation(PtrAlloc).


//----------------------------
// Call-Graph
//----------------------------

callgraph:edge(CalleeCtx, Callee, CallerCtx, CallerInstr) ->
   context(CallerCtx), instruction(CallerInstr),
   context(CalleeCtx), function_decl(Callee).
