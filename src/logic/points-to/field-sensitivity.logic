//------------------------------------------------------------------------------
// [Field Sensitive treatment of `getelementptr` instructions]
//
// We create subregions on the fly to act as destinations of
// instructions that may point to an allocation at some
// *offset*. Essentially, we create complex allocations paired with
// access paths in a demand-driven way, according to the given indices
// of some GEP instruction where an existing allocation is used as the
// base operand.

// Note that a subregion allocation created at some GEP instruction
// will be identified and used by other instructions too that happen
// to reference the same base allocation with the same offset.
//
// We filter null and other pseudo-allocations without depth by
// requiring that the base of the new region should itself have a
// depth.
//------------------------------------------------------------------------------


// Compute intermediate points to for `getelementptr` instruction up
// to some index

gep_points_to(Insn, Index, Alloc) ->
   getelementptr_instruction(Insn),
   int[64](Index),
   allocation(Alloc).

gep_points_to(Insn, Index, Alloc) <-
   gep_points_to(Insn, Index, SomeAlloc),
   alloc_aliases(Alloc, SomeAlloc).

gep_points_to(Insn, 0, Alloc) <-
   !gep:vector_based(Insn),
   getelementptr_instruction:base[Insn] = Base,
   operand_points_to(Alloc, Base).
// TODO check type compatibility

//----------------------------------------------------------
// For the first index of the GEP instruction
//----------------------------------------------------------

// First zero index is ignored when address operand points-to non-base
// object.

gep_points_to(Insn, 1, Alloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   alloc_subregion(Alloc),
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = 0.


// The first non-zero index must be added to the previous index of the
// allocation to produce a new offset

_gep_with_nonzero_base_offset[Insn] = Index <-
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = Index,
   Index != 0.

gep_points_to(Insn, 1, NewAlloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // constant non-zero first index
   _gep_with_nonzero_base_offset[Insn] = Index,
   // get existing allocation at new index
   _array_index_subobject:at_offset[Alloc, Index] = NewAlloc,
   // check for type compatibility
   allocation:type[NewAlloc] = Type, // old type may not be compatible
   type_compatible(Type, DeclaredType).

// Fetch an array index subobject given another array index subobject
// as a base, plus some offset to its index.
_array_index_subobject:at_offset[Alloc, Offset] = NewAlloc <-
   alloc_subregion:at_array_index[Base, Index] = Alloc,
   alloc_subregion:at_array_index[Base, Index + Offset] = NewAlloc.


// The first index, if unknown, must be used to generate a new
// star-index allocation that replaces the older constant index

gep_points_to(Insn, 1, NewAlloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   type_compatible(Type, DeclaredType),
   // variable first index
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   !operand:to_int[IndexOp] = _,
   // allocation pointed to some specific (known) element
   alloc_subregion:at_array_index[Base, _] = Alloc,
   alloc_subregion:at_any_array_index[Base] = NewAlloc,
   alloc_subregion:base[Alloc] = Base. // OPT: redundant clause


// First index is also ignored when address points-to non-base object
// with variable array index, since adding the new first index will
// not change anything. Thus, it suffices to propagate the existing
// allocation

gep_points_to(Insn, 1, Alloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   alloc_subregion:at_any_array_index[Base] = Alloc,
   alloc_subregion:base[Alloc] = Base. // OPT: redundant clause


// We point to the aliased zero index of a base allocation, as if it
// had been an array allocation, whenever the base allocation flows to
// the address operand of some GEP instruction.

gep_points_to(Insn, 0, ZeroAliasAlloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   // first index can be anything
   getelementptr_instruction:index[Insn, 0] = _,
   // base object
   basic_allocation(Alloc),
   alloc_subregion:at_array_index[Alloc, 0] = ZeroAliasAlloc.


// When address operand points-to base object, then we must record the
// index accordingly

gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   type_compatible(Type, DeclaredType),
   // base object
   basic_allocation(Alloc),
   // first index is a constant
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = Index,
   // get subojbect at this array index
   alloc_subregion:at_array_index[Alloc, Index] = Region.


gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   type_compatible(Type, DeclaredType),
   // base object
   basic_allocation(Alloc),
   // first index is a variable
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   !operand:to_int[IndexOp] = _,
   // get subobject at star array index
   alloc_subregion:at_any_array_index[Alloc] = Region.


// It also possible that a struct type is treated as an array of
// bytes, in which case we must match the byte offset to some field

gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   // Base type of GEP is pointer to i8
   getelementptr_instruction:base_type[Insn] = PtrType,
   pointer_type:component[PtrType] = i8,
   int8_type[] = i8,
   // first index is a constant
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = Offset,
   // match byte offset to field
   allocation:type[Alloc] = Type,
   struct_type(Type),
   struct_type:field_offset[Type, Field] = Offset,
   // get subobject of this field
   alloc_subregion:at_field[Alloc, Field] = Region.


//----------------------------------------------------------
// For the rest of the indices of the GEP instruction
//----------------------------------------------------------

gep_interm_points_to_array(Insn, Index, Alloc)
 <-
   gep_points_to(Insn, Index, Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   array_type(Type),
   array_type(DeclaredType),
   type_compatible(Type, DeclaredType),
   alloc_subregion(Alloc).

// Case of unknown index

gep_points_to(Insn, NextIndex, Region)
 <-
   gep_interm_points_to_array(Insn, Index, Alloc),
   // variable array index
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   !operand:to_int[IndexOp] = _,
   // NextIndex = Index + 1
   instruction:next_index[Insn, Index] = NextIndex,
   // get subobject at *star* (unknown) index
   alloc_subregion:at_any_array_index[Alloc] = Region.


// Case of known constant index

gep_points_to(Insn, NextIndex, Region)
 <-
   gep_interm_points_to_array(Insn, Index, Alloc),
   // get constant array index (as integer)
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   operand:to_int[IndexOp] = ConstantIndex,
   // NextIndex = Index + 1
   instruction:next_index[Insn, Index] = NextIndex,
   // get subobject for given array index
   alloc_subregion:at_array_index[Alloc, ConstantIndex] = Region.


// Case of field access

gep_points_to(Insn, NextIndex, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   struct_type(Type),
   struct_type(DeclaredType),
   type_compatible:up_to_field(Type, DeclaredType, Field),
   // get field (as integer constant)
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   operand:to_int[IndexOp] = Field,
   // NextIndex = Index + 1
   instruction:next_index[Insn, Index] = NextIndex,
   // get subobject for given field
   alloc_subregion:at_field[Alloc, Field] = Region.



// The destination variable holds the allocation pointed by the last
// index of the associated `getelementptr` instruction

var_points_to(Alloc, ToVar) <-
   getelementptr_instruction:nindices[Insn] = Total,
   gep_points_to(Insn, Total, Alloc),
   instruction:to[Insn] = ToVar.
// TODO type compatibility
