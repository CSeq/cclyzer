//------------------------------------------------------------------------------
// [Definition of memory subregions (as subtypes of allocation)]
//
// We define a subregion as either (i) a field of an existing region
// (which itself is either a subregion or a normal allocation), or
// (ii) an array index of an existing region.

// Since, our approach is field-sensitive but array-insensitive we do
// not track the exact array index, but instead smush all possible
// array indices into the same pseudo subregion object.
//------------------------------------------------------------------------------

alloc_subregion(Region) -> allocation(Region).
lang:entity(`alloc_subregion).

alloc_subregion:at_field[Alloc, Index] = Region ->
   allocation(Alloc), int[64](Index), alloc_subregion(Region).

alloc_subregion:at_array_index[Alloc] = Region ->
   allocation(Alloc), alloc_subregion(Region).

lang:constructor(`alloc_subregion:at_array_index).
lang:constructor(`alloc_subregion:at_field).

// Define region base

alloc_subregion:base[Region] = Base ->
   alloc_subregion(Region), allocation(Base).

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_field[Base, _] = Region.

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_array_index[Base] = Region.

//------------------------------------------------------------------------
// [Maximum Subobject Depth]
//
// Note that pointer arithmetic and other C idioms may cause infinite
// recursion and creation of new subobjects. For instance, the
// instruction: `ptr = ptr + 1` when translated to a `getelementptr`
// instruction, it will create a new subobject relative to the one
// that `ptr` points to with some offset. However, this subobject will
// again flow to the base variable `ptr` triggering the creation of
// yet a new subobject. This creation of new subobjects will continue
// indefinitely.
//
// To avoid non-termination we introduce a bound to object
// depth. Hence, we do not create a new subobject when this bound is
// going to be exceeded.
//------------------------------------------------------------------------

field_sensitivity:max_depth[] = N ->
   int[64](N).

field_sensitivity:max_depth[] = 7.

allocation:depth[Alloc] = N ->
   allocation(Alloc), int[64](N).

allocation:depth[Alloc] = 0
 <-
   basic_allocation(Alloc).

allocation:depth[Region] = N + 1
 <-
   alloc_subregion:base[Region] = Base,
   allocation:depth[Base] = N.


//-------------------------------------
// String Representation Protocol
//-------------------------------------

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_array_index[Alloc] = Region,
   allocation:to_string[Alloc] = AllocStr,
   RegionStr = AllocStr + "[*]".

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_field[Alloc, Index] = Region,
   allocation:to_string[Alloc] = AllocStr,
   int64:string:convert[Index] = IndexStr,
   RegionStr = AllocStr + ".$" + IndexStr.


//-------------------------------------------------------------------
// Field Sensitive treatment of `getelementptr` instructions
//-------------------------------------------------------------------


// Compute intermediate points to for `getelementptr` instruction up
// to some index

gep_points_to(Insn, Index, Alloc) ->
   getelementptr_instruction(Insn),
   int[64](Index),
   allocation(Alloc).

gep_points_to(Insn, 1, Alloc) <-
   !gep:vector_based(Insn),
   getelementptr_instruction:base[Insn] = Base,
   operand_points_to(Alloc, Base).

// Create subregions on the fly to act as destinations of instructions
// that may point to an allocation at some *offset*.
//
// We filter null and other pseudo-allocations without depth by
// requiring that the base of the new region should itself have a depth.

alloc_subregion(Region)
 , alloc_subregion:at_array_index[Alloc] = Region
 , allocation:depth[Region] = N + 1
 , gep_points_to(Insn, Next, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   allocation:depth[Alloc] = N,
   field_sensitivity:max_depth[] = Max,
   N < Max,
   getelementptr_instruction:interm_type[Insn, Index] = Type,
   array_type(Type),
   instruction:next_index[Insn, Index] = Next.

alloc_subregion(Region)
 , alloc_subregion:at_field[Alloc, Field] = Region
 , allocation:depth[Region] = N + 1
 , gep_points_to(Insn, Next, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   allocation:depth[Alloc] = N,
   field_sensitivity:max_depth[] = Max,
   N < Max,
   getelementptr_instruction:interm_type[Insn, Index] = Type,
   struct_type(Type),
   getelementptr_instruction:index[Insn, Index] = FieldOp,
   operand:as_constant[FieldOp] = Constant,
   constant:to_int[Constant] = Field,
   instruction:next_index[Insn, Index] = Next.

// !! Generic fallback rule !! Whenever the maximum depth is reached
// the indices are therefore ignored and we switch to a
// field-insensitive approach beyond that, i.e., just propagating the
// object that was pointed to up to the previous index. In effect,
// when a memory region reaches its maximum depth, the points-to
// relation regarding this region is about any word contained in that
// region (that can be a pointer).

gep_points_to(Insn, Next, Alloc)
 <-
   gep_points_to(Insn, Index, Alloc),
   allocation:depth[Alloc] = N,
   field_sensitivity:max_depth[] = N,
   instruction:next_index[Insn, Index] = Next.

// The destination variable holds the allocation pointed by the last
// index of the associated `getelementptr` instruction

var_points_to(Alloc, ToVar) <-
   getelementptr_instruction:nindices[Insn] = Total,
   gep_points_to(Insn, Total, Alloc),
   instruction:to[Insn] = ToVar.


//-------------------------------------------------------------------
// [Memcpy instructions]
//
//  We must treat `memcpy` instructions in such a way as to ensure
//  that it may change the points-to set of any subregion of memory
//  that is being copied.
//-------------------------------------------------------------------

memcpy(Insn, To, From) ->
   instruction(Insn), allocation(To), allocation(From).

memcpy(Insn, DestSubobject, SrcSubobject) <-
   memcpy(Insn, DestObject, SrcObject),
   alloc_subregion:at_field[DestObject, Field] = DestSubobject,
   alloc_subregion:at_field[SrcObject, Field] = SrcSubobject.

memcpy(Insn, ToSubobject, FromSubobject) <-
   memcpy(Insn, ToObject, FromObject),
   alloc_subregion:at_array_index[ToObject] = ToSubobject,
   alloc_subregion:at_array_index[FromObject] = FromSubobject.

ptr_points_to(Alloc, To) <-
   memcpy(_, To, From),
   ptr_points_to(Alloc, From).

// `memcpy` call instructions
memcpy(CallInsn, ToAlloc, FromAlloc) <-
   function:name[Callee] = Name,
   ( string:like(Name, "@memcpy%")
   ; string:like(Name, "@llvm.memcpy%") ),
   callgraph:edge(Callee, CallInsn),
   call_instruction:arg[CallInsn, 0] = To,
   call_instruction:arg[CallInsn, 1] = From,
   operand_points_to(FromAlloc, From),
   operand_points_to(ToAlloc, To).


//------------------------------------
// Region containment
//------------------------------------

region_contains(Outer, Inner) ->
   alloc_subregion(Inner), allocation(Outer).

region_contains(Outer, Inner) <-
   alloc_subregion:at_array_index[Outer] = Inner.

region_contains(Outer, Inner) <-
   alloc_subregion:at_field[Outer, _] = Inner.

region_contains(Outer, Inner) <-
   region_contains(Interm, Inner),
   region_contains(Outer, Interm).

// Null cannot contain anything

null_location[] = Null ->
   !region_contains(Null, _).
