//------------------------------------------------------------------------------
// [Definition of memory subregions (as subtypes of allocation)]
//
// We define a subregion as either (i) a field of an existing region
// (which itself is either a subregion or a normal allocation), or
// (ii) an array/pointer index of an existing region.
//
// In the second case, the index can be either a constant (which we
// record) or a variable. This corresponds to two different
// constructors, that in essence produce two distinct algebraic data
// types (plus a single one for referencing struct fields).
//
// When the index is unknown on the other hand (variable case), there
// is no index to record. In the string representation protocol as
// well as in code documentation, we will represent the unknown index
// with a star (*).
//
// As a final note, the need to create subregions stems from the fact
// that in C, we can refer to field addresses, and at a later point
// dereference them. This translates to a `getelementptr` instruction
// that computes the offset from a base pointer variable and assigns
// it to some other variable, which may then be supplied as the
// address operand to a `load`/`store` instruction. These two
// instructions may reside in different functions, so an
// intraprocedural matching would not work.
//
// This is an important difference with the Java Bytecode IR, where no
// such thing is possible and a single relation that connects two
// abstract objects (memory allocations) through some field is
// sufficient.
//------------------------------------------------------------------------------

alloc_subregion(Region) -> allocation(Region).
lang:entity(`alloc_subregion).

//---------------------------------------------------------------
// [Field Selections]
//---------------------------------------------------------------

// Single constructor for field selections

alloc_subregion:at_field[Alloc, Index] = Region ->
   allocation(Alloc), int[64](Index), alloc_subregion(Region).

lang:constructor(`alloc_subregion:at_field).

// Create every field sub-expression, once type for base object is
// established

alloc_subregion(NewAlloc)
 , alloc_subregion:at_field[Alloc, Field] = NewAlloc
 , allocation:type[NewAlloc] = FieldType
 <-
   allocation:type[Alloc] = Type,
   // filter base allocations
   alloc_subregion(Alloc),
   // determine type
   struct_type(Type),
   struct_type:field[Type, Field] = FieldType.


//---------------------------------------------------------------
// [Array Element Selections: unknown *star* index]
//---------------------------------------------------------------

// Constructor for unknown array/pointer index

alloc_subregion:at_any_array_index[Alloc] = Region ->
   allocation(Alloc), alloc_subregion(Region).

lang:constructor(`alloc_subregion:at_any_array_index).


// Create star pointer index expression, once type for base object is
// established

alloc_subregion(NewAlloc)
 , alloc_subregion:at_any_array_index[Alloc] = NewAlloc
 , allocation:type[NewAlloc] = Type
 <-
   allocation:type[Alloc] = Type,
   // base object
   basic_allocation(Alloc).

// Create star array index expression, once type for base object is
// established

alloc_subregion(NewAlloc)
 , alloc_subregion:at_any_array_index[Alloc] = NewAlloc
 , allocation:type[NewAlloc] = ElementType
 <-
   allocation:type[Alloc] = Type,
   // filter base allocations
   alloc_subregion(Alloc),
   // determine type
   array_type(Type),
   array_type:component[Type] = ElementType.


//---------------------------------------------------------------
// [Array Element Selections: known index]
//---------------------------------------------------------------

// Constructor for constant array/pointer index

alloc_subregion:at_array_index[Alloc, Index] = Region ->
   allocation(Alloc), int[64](Index), alloc_subregion(Region).

lang:constructor(`alloc_subregion:at_array_index).


// Create every pointer index expression, once type for base object is
// established

alloc_subregion(NewAlloc)
 , alloc_subregion:at_array_index[Alloc, Index] = NewAlloc
 , allocation:type[NewAlloc] = Type
 <-
   allocation:type[Alloc] = Type,
   // base object
   basic_allocation(Alloc),
   // first index is a constant
   pointer_index(Index).

// Create star array index expression, once type for base object is
// established

alloc_subregion(NewAlloc)
 , alloc_subregion:at_array_index[Alloc, Index] = NewAlloc
 , allocation:type[NewAlloc] = ElementType
 <-
   allocation:type[Alloc] = Type,
   // filter base allocations
   alloc_subregion(Alloc),
   // determine type
   array_type(Type),
   array_type:component[Type] = ElementType,
   // accept any relevant array index for this type
   array_indices(Type, Index).


// Find all statically possible pointer indices

pointer_index(Index) -> int[64](Index).
pointer_index(0).

pointer_index(Index) <-
   getelementptr_instruction:index[_, 0] = IndexOp,
   operand:to_int[IndexOp] = Index.

// Find all statically possible array indices

array_indices(Type, Index) ->
   array_type(Type), int[64](Index).

array_indices(Type, ConstantIndex) <-
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   getelementptr_instruction:interm_type[Insn, Index] = DeclaredType,
   operand:to_int[IndexOp] = ConstantIndex,
   array_type(DeclaredType),
   array_type(Type),
   type_compatible(Type, DeclaredType).


//-------------------------------------------------------------------
// Subobject properties
//-------------------------------------------------------------------

// Region base: unified predicate that applies to all types of
// subobjects

alloc_subregion:base[Region] = Base ->
   alloc_subregion(Region), allocation(Base).

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_field[Base, _] = Region.

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_any_array_index[Base] = Region.

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_array_index[Base, _] = Region.


//-------------------------------------
// String Representation Protocol
//-------------------------------------

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_array_index[Alloc, Index] = Region,
   allocation:to_string[Alloc] = AllocStr,
   int64:string:convert[Index] = IndexStr,
   RegionStr = AllocStr + "[" + IndexStr + "]".

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_any_array_index[Alloc] = Region,
   allocation:to_string[Alloc] = AllocStr,
   RegionStr = AllocStr + "[*]".

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_field[Alloc, Index] = Region,
   allocation:to_string[Alloc] = AllocStr,
   int64:string:convert[Index] = IndexStr,
   RegionStr = AllocStr + ".f$" + IndexStr.


//------------------------------------------------------------------------
// [Deprecated: Maximum Subobject Depth]
//
// Note that pointer arithmetic and other C idioms may cause infinite
// recursion and creation of new subobjects. For instance, the
// instruction: `ptr = ptr + 1` when translated to a `getelementptr`
// instruction, it will create a new subobject relative to the one
// that `ptr` points to with some offset. However, this subobject will
// again flow to the base variable `ptr` triggering the creation of
// yet a new subobject. This creation of new subobjects will continue
// indefinitely.
//
// DEPRECATED:
// To avoid non-termination we introduce a bound to object
// depth. Hence, we do not create a new subobject when this bound is
// going to be exceeded.
//
// Since we now create subobjects (e.g., by field access, or array
// indexing) *only* when the analysis has discovered the type of the
// base object, we no longer need a bound on object depth. Types alone
// are sufficient to prohibit infinite object recursion, since the
// type of the base object will always have a greater size compared to
// that of any of its subobjects. Hence, as the object depth grows,
// the object size will become smaller until it reaches zero (no
// infinite recursion is possible).
//------------------------------------------------------------------------

// field_sensitivity:max_depth[] = N ->
//    int[64](N).

// field_sensitivity:max_depth[] = 5.

// alloc_subregion(Alloc) -> allocation:depth[Alloc] = _.

// _may_expand_base_alloc(Alloc) -> allocation(Alloc).
// _may_expand_alloc_with_field(Alloc) -> allocation(Alloc).

// lang:isEntity[`_may_expand_base_alloc] = false.
// lang:isEntity[`_may_expand_alloc_with_field] = false.

// Allocation is allowed to create subobjects as maximum depth has not
// been reached

// _may_expand_base_alloc(Alloc) <-
//    field_sensitivity:max_depth[] = MaxDepth,
//    allocation:depth[Alloc] = N,
//    N < MaxDepth.

//------------------------------------------------------------------------------
// [Field Sensitive treatment of `getelementptr` instructions]
//
// We create subregions on the fly to act as destinations of
// instructions that may point to an allocation at some
// *offset*. Essentially, we create complex allocations paired with
// access paths in a demand-driven way, according to the given indices
// of some GEP instruction where an existing allocation is used as the
// base operand.

// Note that a subregion allocation created at some GEP instruction
// will be identified and used by other instructions too that happen
// to reference the same base allocation with the same offset.
//
// We filter null and other pseudo-allocations without depth by
// requiring that the base of the new region should itself have a
// depth.
//------------------------------------------------------------------------------


// Compute intermediate points to for `getelementptr` instruction up
// to some index

gep_points_to(Insn, Index, Alloc) ->
   getelementptr_instruction(Insn),
   int[64](Index),
   allocation(Alloc).

gep_points_to(Insn, Index, Alloc) <-
   gep_points_to(Insn, Index, SomeAlloc),
   alloc_aliases(Alloc, SomeAlloc).

gep_points_to(Insn, 0, Alloc) <-
   !gep:vector_based(Insn),
   getelementptr_instruction:base[Insn] = Base,
   operand_points_to(Alloc, Base).

//----------------------------------------------------------
// For the first index of the GEP instruction
//----------------------------------------------------------

// First zero index is ignored when address operand points-to non-base
// object.

gep_points_to(Insn, 1, Alloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   alloc_subregion(Alloc),
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = 0.


// The first non-zero index must be added to the previous index of the
// allocation to produce a new offset

gep_points_to(Insn, 1, NewAlloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // constant non-zero first index
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = Index,
   Index != 0,
   // get existing allocation at new index
   alloc_subregion:at_array_index[Base, PrevIndex] = Alloc,
   alloc_subregion:at_array_index[Base, PrevIndex + Index] = NewAlloc,
   // check for type compatibility
   allocation:type[NewAlloc] = Type, // old type may not be compatible
   type_compatible(Type, DeclaredType).


// The first index, if unknown, must be used to generate a new
// star-index allocation that replaces the older constant index

gep_points_to(Insn, 1, NewAlloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   type_compatible(Type, DeclaredType),
   // variable first index
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   !operand:to_int[IndexOp] = _,
   // allocation pointed to some specific (known) element
   alloc_subregion:at_array_index[Base, _] = Alloc,
   alloc_subregion:at_any_array_index[Base] = NewAlloc.


// First index is also ignored when address points-to non-base object
// with variable array index, since adding the new first index will
// not change anything. Thus, it suffices to propagate the existing
// allocation

gep_points_to(Insn, 1, Alloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   alloc_subregion:at_any_array_index[_] = Alloc.


// We point to the aliased zero index of a base allocation, as if it
// had been an array allocation, whenever the base allocation flows to
// the address operand of some GEP instruction.

gep_points_to(Insn, 0, ZeroAliasAlloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   // first index can be anything
   getelementptr_instruction:index[Insn, 0] = _,
   // base object
   basic_allocation(Alloc),
   alloc_subregion:at_array_index[Alloc, 0] = ZeroAliasAlloc.


// When address operand points-to base object, then we must record the
// index accordingly

gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   type_compatible(Type, DeclaredType),
   // base object
   basic_allocation(Alloc),
   // first index is a constant
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = Index,
   // get subojbect at this array index
   alloc_subregion:at_array_index[Alloc, Index] = Region.


gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   getelementptr_instruction:interm_type[Insn, 1] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   type_compatible(Type, DeclaredType),
   // base object
   basic_allocation(Alloc),
   // first index is a variable
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   !operand:to_int[IndexOp] = _,
   // get subobject at star array index
   alloc_subregion:at_any_array_index[Alloc] = Region.


// It also possible that a struct type is treated as an array of
// bytes, in which case we must match the byte offset to some field

gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   // Base type of GEP is pointer to i8
   getelementptr_instruction:base_type[Insn] = PtrType,
   pointer_type:component[PtrType] = i8,
   int8_type[] = i8,
   // first index is a constant
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = Offset,
   // match byte offset to field
   allocation:type[Alloc] = Type,
   struct_type(Type),
   struct_type:field_offset[Type, Field] = Offset,
   // get subobject of this field
   alloc_subregion:at_field[Alloc, Field] = Region.


//----------------------------------------------------------
// For the rest of the indices of the GEP instruction
//----------------------------------------------------------

// Case of unknown index

gep_points_to(Insn, NextIndex, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   array_type(Type),
   array_type(DeclaredType),
   type_compatible(Type, DeclaredType),
   alloc_subregion(Alloc),
   // variable array index
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   !operand:to_int[IndexOp] = _,
   // NextIndex = Index + 1
   instruction:next_index[Insn, Index] = NextIndex,
   // get subobject at *star* (unknown) index
   alloc_subregion:at_any_array_index[Alloc] = Region.


// Case of known constant index

gep_points_to(Insn, NextIndex, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   array_type(Type),
   array_type(DeclaredType),
   type_compatible(Type, DeclaredType),
   alloc_subregion(Alloc),
   // get constant array index (as integer)
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   operand:to_int[IndexOp] = ConstantIndex,
   // NextIndex = Index + 1
   instruction:next_index[Insn, Index] = NextIndex,
   // get subobject for given array index
   alloc_subregion:at_array_index[Alloc, ConstantIndex] = Region.


// Case of field access

gep_points_to(Insn, NextIndex, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = DeclaredType,
   // check for type compatibility
   allocation:type[Alloc] = Type,
   struct_type(Type),
   struct_type(DeclaredType),
   type_compatible:up_to_field(Type, DeclaredType, Field),
   // get field (as integer constant)
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   operand:to_int[IndexOp] = Field,
   // NextIndex = Index + 1
   instruction:next_index[Insn, Index] = NextIndex,
   // get subobject for given field
   alloc_subregion:at_field[Alloc, Field] = Region.



// The destination variable holds the allocation pointed by the last
// index of the associated `getelementptr` instruction

var_points_to(Alloc, ToVar) <-
   getelementptr_instruction:nindices[Insn] = Total,
   gep_points_to(Insn, Total, Alloc),
   instruction:to[Insn] = ToVar.


//------------------------------------------------------------------------
// [Implicit Pointer Aliases]
//
// In C, the expression `ptr[0]` and `*ptr` is the same. The 0 index
// is often omitted from some instructions, but we must ensure that
// such expressions are treated as aliases by the analysis and have
// the same points-to sets.
//
// Note that this relation denotes *definite* (must) aliases. This
// does not include possible aliases, like when a variable array index
// may be equal to some constant c, and so X[*] *may* be aliased to
// X[c]. For the latter concept, see the alloc_matches relation.
//------------------------------------------------------------------------

alloc_aliases(Alloc1, Alloc2) ->
   allocation(Alloc1), allocation(Alloc2).

// Reflexivity

alloc_aliases(Alloc, Alloc) <-
   allocation(Alloc).

// Transitivity

alloc_aliases(Alloc1, Alloc2) <-
   alloc_aliases(Alloc1, IntermAlloc),
   alloc_aliases(Alloc2, IntermAlloc).

// Symmetricitity

alloc_aliases(Alloc1, Alloc2) <-
   alloc_aliases(Alloc2, Alloc1).

// Aliases have the same points-to sets

ptr_points_to(Alloc, BaseAlloc1) <-
   ptr_points_to(Alloc, BaseAlloc2),
   alloc_aliases(BaseAlloc1, BaseAlloc2).

// When a pointer points to an allocation, it must also point to all
// of its aliases

ptr_points_to(Alloc1, BaseAlloc) <-
   ptr_points_to(Alloc2, BaseAlloc),
   alloc_aliases(Alloc1, Alloc2).


// A base allocation with zero index is an alias to base. The first
// field is also and alias to base, as it too points to the exact same
// memory location.

alloc_aliases(Base, ZeroIndexBase) <-
   alloc_subregion:at_array_index[Base, 0] = ZeroIndexBase.

alloc_aliases(Base, FirstField) <-
   alloc_subregion:at_field[Base, 0] = FirstField.


// Note !!! Aliased bases will *not* result in aliased subregions when
// extended by the same field or index. See `Why don’t GEP x,0,0,1 and
// GEP x,1 alias?` from http://llvm.org/docs/GetElementPtr.html



//------------------------------------------------------------------------
// [Pattern Matching Star Expressions]
//
// By allowing star expressions in subregion allocations, we must
// ensure that when loading from some allocation we consider all other
// allocation that could potentially alias the former.  An allocation
// that contains a star expression (unknown index) is more generic
// than any allocation where the star is replaced by a specific
// constant index.
//
// For instance, when loading from an address that points-to an
// allocation such as `Base[1][*].$1[*][3]`, the possible dereferenced
// locations are not just those of its points-to set, but also those
// from `Base[1][c1].$1[c2][3]` for any c1, c2 constants (or even just
// one of them).
//
// To be able to reason about such relations between complex
// allocations, we define a relation (actually a partial-order)
// between allocations a1 and a2 that detects when a2 can pattern
// match a1 by replacing any or all of its star expressions with some
// constant indices.
//------------------------------------------------------------------------


// `StarredAlloc` is more generic than (ie, can pattern match)
// `Alloc`.

alloc_matches(Alloc, StarredAlloc) ->
   allocation(Alloc), allocation(StarredAlloc).

alloc_matches(Alloc, Alloc) <-
   allocation(Alloc).

alloc_matches(Alloc, StarredAlloc) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_array_index[Base1, _] = Alloc,
   alloc_subregion:at_any_array_index[Base2] = StarredAlloc.

// TODO check with aliases
alloc_matches(Base1, StarredAlloc) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_any_array_index[Base2] = StarredAlloc.

alloc_matches(Alloc1, Alloc2) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_array_index[Base1, Index] = Alloc1,
   alloc_subregion:at_array_index[Base2, Index] = Alloc2.

alloc_matches(Alloc1, Alloc2) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_field[Base1, Field] = Alloc1,
   alloc_subregion:at_field[Base2, Field] = Alloc2.


// When loading from an allocation we must also consider the more
// specific matching allocations and merge their points-to sets also.

var_points_to(Alloc, ToVar) <-
   reachable_instruction(Insn),
   instruction:to[Insn] = ToVar,
   load_instruction:address[Insn] = PtrOp,
   operand_points_to(OrigAlloc, PtrOp),
   alloc_matches(LessGenericAlloc, OrigAlloc),
   ptr_points_to(Alloc, LessGenericAlloc).

// We must also ensure that matching is considered in the opposite
// direction. We do that by extending the points-to set of an
// allocation by the points-to sets of all more generic allocations,
// ie, those that can pattern match it.

ptr_points_to(Alloc, OrigAlloc) <-
   ptr_points_to(Alloc, MoreGenericAlloc),
   alloc_matches(OrigAlloc, MoreGenericAlloc).


//-------------------------------------------------------------------
// [Memcpy instructions]
//
//  We must treat `memcpy` instructions in such a way as to ensure
//  that it may change the points-to set of any subregion of memory
//  that is being copied.
//-------------------------------------------------------------------

memcpy(Insn, To, From) ->
   instruction(Insn), allocation(To), allocation(From).

// Copy points-to set of copied objects

ptr_points_to(Alloc, To) <-
   memcpy(_, To, From),
   ptr_points_to(Alloc, From).

// Base case of `memcpy` call instructions It should handle syntactic
// aliases. For instance `memcpy(to,from)` is equivalent to
// `memcpy(to, &from[0])`. We consider all possible aliases of the
// base objects that flow to the operands of the @memcpy instruction,
// but only keep type compatible pairs.

memcpy(CallInsn, AliasedTo, AliasedFrom) <-
   function:name[Callee] = Name,
   ( string:like(Name, "@memcpy%")
   ; string:like(Name, "@llvm.memcpy%") ),
   callgraph:edge(Callee, CallInsn),
   call_instruction:arg[CallInsn, 0] = To,
   call_instruction:arg[CallInsn, 1] = From,
   operand_points_to(FromAlloc, From),
   operand_points_to(ToAlloc, To),
   // consider any possible aliases
   alloc_aliases(AliasedTo, ToAlloc),
   alloc_aliases(AliasedFrom, FromAlloc),
   // check type compatibility
   allocation:type[AliasedTo] = ToType,
   allocation:type[AliasedFrom] = FromType,
   type_compatible(FromType, ToType).


// Recursive case for `memcpy` call instructions
//
// !! Note that in the following cases we have to create the
// destination subobject if it does not exist already, since we cannot
// afford to miss its points-to set because it may be copied to more
// generic objects that contain star expressions !!

memcpy(Insn, DestSubobject, SrcSubobject)
 <-
   memcpy(Insn, DestObject, SrcObject),
   // get source and destination subobjects for given field
   alloc_subregion:at_field[SrcObject, Field] = SrcSubobject,
   alloc_subregion:at_field[DestObject, Field] = DestSubobject,
   // check for type compatibility
   allocation:type[SrcSubobject] = SrcType,
   allocation:type[DestSubobject] = DestType,
   type_compatible(SrcType, DestType).


memcpy(Insn, DestSubobject, SrcSubobject)
 <-
   memcpy(Insn, DestObject, SrcObject),
   // get source and destination subobjects
   alloc_subregion:at_array_index[SrcObject, Index] = SrcSubobject,
   alloc_subregion:at_array_index[DestObject, Index] = DestSubobject,
   // check for type compatibility
   allocation:type[SrcSubobject] = SrcType,
   allocation:type[DestSubobject] = DestType,
   type_compatible(SrcType, DestType).


memcpy(Insn, DestSubobject, SrcSubobject)
 <-
   memcpy(Insn, DestObject, SrcObject),
   // get source and destination subobjects for star index
   alloc_subregion:at_any_array_index[SrcObject] = SrcSubobject,
   alloc_subregion:at_any_array_index[DestObject] = DestSubobject,
   // check for type compatibility
   allocation:type[SrcSubobject] = SrcType,
   allocation:type[DestSubobject] = DestType,
   type_compatible(SrcType, DestType).


//------------------------------------
// Region containment
//------------------------------------

region_contains(Outer, Inner) ->
   alloc_subregion(Inner), allocation(Outer).

region_contains(Outer, Inner) <-
   alloc_subregion:at_any_array_index[Outer] = Inner.

region_contains(Outer, Inner) <-
   alloc_subregion:at_array_index[Outer, _] = Inner.

region_contains(Outer, Inner) <-
   alloc_subregion:at_field[Outer, _] = Inner.

region_contains(Outer, Inner) <-
   region_contains(Interm, Inner),
   region_contains(Outer, Interm).

// Null cannot contain anything

null_location[] = Null ->
   !region_contains(Null, _).



//------------------------------------------------------------------------------
// [Field Sensitivity for `getelementptr` constant expressions]
//
// This is equivalent to the treatment of GEP instructions, but with
// no support for variable indices, as they are not allowed in
// constant expressions.
//------------------------------------------------------------------------------


// Compute intermediate points to for `getelementptr` constant
// expression up to some index

gep_constant_expr_points_to[CExpr, Index] = Alloc ->
   getelementptr_constant_expression(CExpr),
   int[64](Index),
   allocation(Alloc).

gep_constant_expr_points_to[CExpr, 0] = Alloc <-
   getelementptr_constant_expression:base[CExpr] = Base,
   constant_points_to[Base] = Alloc.


// First index as above

gep_constant_expr_points_to[CExpr, 1] = Alloc
 <-
   gep_constant_expr_points_to[CExpr, 0] = Alloc,
   alloc_subregion(Alloc),
   getelementptr_constant_expression:index[CExpr, 0] = Constant,
   constant:to_int[Constant] = 0.


gep_constant_expr_points_to[CExpr, 1] = Region
 <-
   gep_constant_expr_points_to[CExpr, 0] = Alloc,
   basic_allocation(Alloc),
   getelementptr_constant_expression:index[CExpr, 0] = Constant,
   constant:to_int[Constant] = Index,
   alloc_subregion:at_array_index[Alloc, Index] = Region.


// Rest of the indices

gep_constant_expr_points_to[CExpr, NextIndex] = Region
 <-
   gep_constant_expr_points_to[CExpr, Index] = Alloc,
   getelementptr_constant_expression:interm_type[CExpr, Index] = DeclaredType,
   array_type(DeclaredType),
   alloc_subregion(Alloc),
   // get constant array index (as integer)
   getelementptr_constant_expression:index[CExpr, Index] = Constant,
   constant:to_int[Constant] = ConstantIndex,
   // NextIndex = Index + 1
   constant_expression:next_index[CExpr, Index] = NextIndex,
   // get subobject for given index
   alloc_subregion:at_array_index[Alloc, ConstantIndex] = Region.


gep_constant_expr_points_to[CExpr, NextIndex] = Region
 <-
   gep_constant_expr_points_to[CExpr, Index] = Alloc,
   getelementptr_constant_expression:interm_type[CExpr, Index] = DeclaredType,
   struct_type(DeclaredType),
   // get field (as integer constant)
   getelementptr_constant_expression:index[CExpr, Index] = Constant,
   constant:to_int[Constant] = Field,
   // NextIndex = Index + 1
   constant_expression:next_index[CExpr, Index] = NextIndex,
   // get suboject for given field
   alloc_subregion:at_field[Alloc, Field] = Region.


constant_points_to[CExpr] = Alloc <-
   getelementptr_constant_expression:nindices[CExpr] = Total,
   gep_constant_expr_points_to[CExpr, Total] = Alloc.
