//-----------------------------------------------------------------------
// [Memory Abstraction]
//
// We have three types of memory allocations that a variable can point
// to:
// (i)   stack allocations,
// (ii)  heap allocations, and
// (iii) global allocations.
//
// The LLVM bitcode intermediate representation transforms every named
// variable of type `x` to a pointer to `x`, and adds an `alloca`
// instruction at the beginning of the function to allocate space for
// it, in the stack.
//
// Thus, every address-of expression of the source code now
// corresponds to an LLVM bitcode variable.
//
// For instance, the statements:
//
//     int x, *p;
//     ...
//     p = &x;
//
// will be transformed to:
//
//     i32 *x, **p;
//     x = alloca i32
//     p = alloca i32*
//     ...
//     store x, p
//
//
// Since an arbitrary number of heap allocations may happen at
// runtime, we must choose an appropriate abstraction. The most common
// choice for Andersen type analyses is abstracting an allocation by
// the instruction that allocates it. This is what we will follow here
// too.
//
//-----------------------------------------------------------------------

allocation(Alloc) -> .
stack_allocation(Alloc)  -> allocation(Alloc).
heap_allocation(Alloc)   -> allocation(Alloc).
global_allocation(Alloc) -> allocation(Alloc).


// Constructors

stack_allocation:by_instruction[Insn] = StackAlloc ->
   alloca_instruction(Insn), stack_allocation(StackAlloc).

heap_allocation:by_instruction[Insn] = HeapAlloc ->
   instruction(Insn), heap_allocation(HeapAlloc).

global_allocation:by_variable[Var] = GlobalAlloc ->
   global_variable(Var), global_allocation(GlobalAlloc).

global_allocation:by_function[Func] = GlobalAlloc ->
   function(Func), global_allocation(GlobalAlloc).


lang:physical:storageModel[`allocation] = "ScalableSparse".
lang:constructor(`stack_allocation:by_instruction).
lang:constructor(`heap_allocation:by_instruction).
lang:constructor(`global_allocation:by_variable).
lang:constructor(`global_allocation:by_function).


// Human readable representation

variable:descriptor(Var, Path, Func, Type, Name) ->
   variable(Var), string(Path), string(Func), type(Type), string(Name).

variable:id_tokens[Var, Index] = Token <-
   variable:id(Var:Id), string:split[Id, ":", Index] = Token.

variable:descriptor(Var, Path, Func, Type, Name) <-
   variable:id_tokens[Var, 0] = Path,
   variable:id_tokens[Var, 1] = Fn,
   variable:id_tokens[Var, 2] = Name,
   variable:type[Var] = Type,
   Func = "@" + Fn.

allocation:to_string[Alloc] = Str ->
   allocation(Alloc), string(Str).

allocation:to_string[Alloc] = Str <-
   stack_allocation:by_instruction[Insn] = Alloc,
   instruction:to[Insn] = Var,
   variable:descriptor(Var, _, Func, Type, Name),
   Str = "*stack_alloc" + Func + "[" + Type + " " + Name + "]".

allocation:to_string[Alloc] = Str <-
   heap_allocation:by_instruction[Insn] = Alloc,
   instruction:to[Insn] = Var,
   variable:descriptor(Var, _, Func, Type, Name),
   Str = "*heap_alloc" + Func + "[" + Type + " " + Name + "]".

allocation:to_string[Alloc] = Str <-
   global_allocation:by_variable[GVar] = Alloc,
   global_variable:name[GVar] = Name,
   Str = "*global_alloc" + Name.

allocation:to_string[Alloc] = Str <-
   global_allocation:by_function[Func] = Alloc,
   function:name[Func] = Name,
   Str = "*global_alloc" + Name.


// Core concepts

constant:contains_alloc(Alloc, Constant) ->
   allocation(Alloc), constant(Constant).

var_points_to(Alloc, Var) ->
   allocation(Alloc), variable(Var).

ptr_points_to(Alloc, PtrAlloc) ->
   allocation(Alloc), allocation(PtrAlloc).


// This nullary predicate represents any unknown memory location.

unknown_location[] = Unknown ->
   allocation(Unknown).

lang:constructor(`unknown_location).

unknown_location[] = Unknown
 , allocation(Unknown)
 , allocation:to_string[Unknown] = "*unknown*"
 <- .
