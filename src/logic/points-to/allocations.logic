//------------------------------------------------
// [Allocation String Representation Protocol]
//------------------------------------------------

// Human readable representation for stack allocations

allocation:to_string[Alloc] = Str <-
   stack_allocation:by_instruction[Insn] = Alloc,
   instruction:to[Insn] = Var,
   variable:descriptor(Var, _, Func, Type, Name),
   Str = "*stack_alloc" + Func + "[" + Type + " " + Name + "]".

// Human readable representation for heap allocations

allocation:to_string[Alloc] = Str <-
   heap_allocation:by_instruction[Insn] = Alloc,
   instruction:to[Insn] = Var,
   variable:descriptor(Var, _, Func, Type, Name),
   Str = "*heap_alloc" + Func + "[" + Type + " " + Name + "]".

// Human readable representation for global variable allocations

allocation:to_string[Alloc] = Str <-
   global_allocation:by_variable[GVar] = Alloc,
   global_variable:name[GVar] = Name,
   Str = "*global_alloc" + Name.

// Human readable representation for function allocations

allocation:to_string[Alloc] = Str <-
   global_allocation:by_function[Func] = Alloc,
   function:name[Func] = Name,
   Str = "*global_alloc" + Name.


// Auxiliary relations for variables

variable:descriptor(Var, Path, Func, Type, Name) ->
   variable(Var), string(Path), string(Func), type(Type), string(Name).

variable:id_tokens[Var, Index] = Token <-
   variable:id(Var:Id), string:split[Id, ":", Index] = Token.

variable:descriptor(Var, Path, Func, Type, Name) <-
   variable:id_tokens[Var, 0] = Path,
   variable:id_tokens[Var, 1] = Fn,
   variable:id_tokens[Var, 2] = Name,
   variable:type[Var] = Type,
   Func = "@" + Fn.


//----------------------------------------------------------------------
// [Heap and Stack Allocations]
//
// Every named variable of the original source code will have a
// corresponsing `alloca_instruction` that allocates space for it in
// the stack. Hence, we can use these instructions to track stack
// allocations.
//
// Heap allocations on the other side will be created primarily by
// calling the `@malloc` function. More heap allocation functions
// could be added in the future.
//----------------------------------------------------------------------


//----------------------------
// Stack allocations
//----------------------------

stack_allocation(StackAlloc),
stack_allocation:by_instruction[Insn] = StackAlloc,
var_points_to(StackAlloc, Var)
 <-
   alloca_instruction(Insn),
   instruction:to[Insn] = Var.


//----------------------------
// Heap allocations
//----------------------------

heap_allocation(HeapAlloc),
heap_allocation:by_instruction[Insn] = HeapAlloc,
var_points_to(HeapAlloc, Var)
 <-
   heap_alloc_function(Func),
   call_instruction:function[Insn] = Func,
   instruction:to[Insn] = Var.

// Functions that allocate memory on heap
heap_alloc_function(Func) -> function_decl(Func).

heap_alloc_function(Func) <-
   function:by_name["@malloc"]  = Func
 ; function:by_name["@calloc"]  = Func
 ; function:by_name["@realloc"] = Func.


//--------------------------------------
// Global variable allocations
//--------------------------------------

global_allocation(Alloc),
global_allocation:by_variable[GVar] = Alloc
 <-
   global_variable(GVar).

//--------------------------------------
// Allocations for functions
//--------------------------------------

global_allocation(Alloc),
global_allocation:by_function[Func] = Alloc
 <-
   function(Func).

// We also create allocations of functions for which we lack any
// definition, e.g., functions that belong to dynamically linked
// libraries

global_allocation(Alloc),
global_allocation:by_function[Func] = Alloc
 <-
   function_decl(Func),
   !function:definition[Func] = _.


//----------------------------------
// Additional pseudo-allocations
//----------------------------------

unknown_location[] = Unknown
 , allocation(Unknown)
 , allocation:to_string[Unknown] = "*unknown*"
 <- .

null_location[] = Null
 , allocation(Null)
 , allocation:to_string[Null] = "*null*"
 <- .
