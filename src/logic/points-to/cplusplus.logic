//------------------------------------------------------------------------------
// Identify the new() function for C++
//------------------------------------------------------------------------------

// There must be a single allocating function

new_function[] = Func -> function_decl(Func).

// Consider only functions with a single parameter of integer type, no
// definition, and whose unmangled name contains the keyword `new`

new_function[] = Func, heap_alloc_function(Func)
 <-
   function:signature[Func] = Signature,
   function:type[Func] = FType,
   string:like(Signature, "operator new(%)"),
   function_type:param[FType, 0] = Type,
   integer_type(Type),
   function_type:nparams[FType] = 1,
   !function:definition[Func] = _.

// Introduce new heap allocation selector

heap_allocation:by_new[Insn] = HeapAlloc <-
   new_function[] = Func,
   call_instruction:function[Insn] = Func,
   heap_allocation:by_instruction[Insn] = HeapAlloc.

// Compute size

allocation:size[HeapAlloc] = Size <-
   heap_allocation:by_new[Insn] = HeapAlloc,
   call_instruction:arg[Insn, 0] = SizeOp,
   operand:to_int[SizeOp] = Size.


//------------------------------------------------------------------------------
// [Constructor and Type]
//
// In order to infer the object type, we track the flow of the object
// being created to some constructor. Intraprocedurally, there will only
// be a single constructor being called, which will have the correct
// type for the object.
//------------------------------------------------------------------------------

constructor:class_type[Ctor] = ClassType <-
   class_type:constructor(Ctor, ClassType).

// We have a call to a constructor function (associated with type
// `Type`) inside function `InFunction`, where `this` points to
// `Alloc`. Note that the latter may be initialized by many
// constructors, unless it is of a base type.

_init_by_ctor(Type, Ctor, InFunction, Alloc)
 <-
   instruction:function[InitInsn] = InFunction,
   callgraph:edge(Ctor, InitInsn),
   constructor:class_type[Ctor] = Type,
   function:actual_arg(Ctor, 0, This),
   operand_points_to(Alloc, This).


// The actual type of the object must match its size, and the relevant
// constructor must be in the same function that allocates it.

allocation:type[HeapAlloc] = Type <-
   instruction:function[AllocInsn] = InFunction,
   heap_allocation:by_new[AllocInsn] = HeapAlloc,
   allocation:size[HeapAlloc] = Size,
   type:size[Type] = Size,
   _init_by_ctor(Type, _, InFunction, HeapAlloc).


//----------------------------------------------------
// Identify class instances based on inferred type
//----------------------------------------------------

class_instance(Alloc) <-
   allocation:type[Alloc] = Type,
   class_type(Type).

class_instance:constructor[Alloc] = Ctor <-
   allocation:type[Alloc] = Type,
   _init_by_ctor(Type, Ctor, _, Alloc).


//----------------------------------------------------
// Find vtables associated with given class instance
//----------------------------------------------------

class_instance:vtable[Alloc] = VTable
 <-
   class_instance:constructor[Alloc] = Ctor,
   instruction:function[StoreInsn] = Ctor,
   store_instruction:value[StoreInsn] = Value,
   store_instruction:address[StoreInsn] = Pointer,
   operand_points_to(Alloc, Pointer),
   operand:as_constant[Value] = Constant,
   constant_contains_vptr(VTable, Constant).

// Create points-to dereference information for every possible offset
// of every vtable. This way, when a variable points-to some vtable
// with some offset, loading from this address will result in the
// appropriate function.

alloc_subregion(VTableOffset)
 , alloc_subregion:at_array_index[ZeroBase, Index] = VTableOffset
 , ptr_points_to(FAlloc, VTableOffset)
 <-
   vtable:function[VTable, Index] = Function,
   global_allocation:by_variable[VTable] = Base,
   global_allocation:by_function[Function] = FAlloc,
   alloc_subregion:at_array_index[Base, 0] = ZeroBase.


// Note !!! Load instructions on class instances will return the
// object's vtable. The array-sensitive treatment of GEP instructions
// will ensure that the indices are appropriately recorded, so that
// any subsequent dynamic dispatch will be correctly resolved by the
// normal dereference rules !!!
