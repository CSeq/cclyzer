//------------------------------------------------------------------------------
// Identify the new() function for C++
//------------------------------------------------------------------------------

// There must be a single allocating function

new_function[] = Func -> function_decl(Func).

// Consider only functions with a single parameter of integer type, no
// definition, and whose unmangled name contains the keyword `new`

new_function[] = Func, heap_alloc_function(Func)
 <-
   function:signature[Func] = Signature,
   function:type[Func] = FType,
   string:like(Signature, "operator new(%)"),
   function_type:param[FType, 0] = Type,
   integer_type(Type),
   function_type:nparams[FType] = 1,
   !function:definition[Func] = _.

// Introduce new heap allocation selector

heap_allocation:by_new[Insn] = HeapAlloc <-
   new_function[] = Func,
   call_instruction:function[Insn] = Func,
   heap_allocation:by_instruction[Insn] = HeapAlloc.

// Compute size

allocation:size[HeapAlloc] = Size <-
   heap_allocation:by_new[Insn] = HeapAlloc,
   call_instruction:arg[Insn, 0] = SizeOp,
   operand:to_int[SizeOp] = Size.


//------------------------------------------------------------------------------
// [Constructor and Type]
//
// In order to infer the object type, we track the flow of the object
// being created to some constructor. Intraprocedurally, there will only
// be a single constructor being called, which will have the correct
// type for the object.
//------------------------------------------------------------------------------

constructor:class_type[Ctor] = ClassType <-
   class_type:constructor(Ctor, ClassType).

allocation:type[HeapAlloc] = Type <-
   heap_allocation:by_new[AllocInsn] = HeapAlloc,
   instruction:function[AllocInsn] = InFunction,
   instruction:function[InitInsn] = InFunction,
   callgraph:edge(Ctor, InitInsn),
   constructor:class_type[Ctor] = Type,
   type:size[Type] = Size,
   allocation:size[HeapAlloc] = Size.
