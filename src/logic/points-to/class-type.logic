//-----------------
// Class Types
//-----------------

// Class types are a subset of struct types

class_type(Type) -> struct_type(Type).


// The name (as it appears in source code) of the class

class_type:name[Type] = Name ->
   class_type(Type), string(Name).

// We follow a heuristic approach to identify class types, by
// searching for struct types with a specific prefix (namely,
// `%class.`).

class_type(Type), class_type:name[Type] = Name
 <-
   struct_type(Type),
   type:id(Type:FQName),
   string:like(FQName, "%%class.%"),
   string:length[FQName] = N,
   string:substring[FQName, 7, N - 7] = Name. // 7 is the length of the prefix "%class."

class_type:by_name[Name] = Type <-
   class_type:name[Type] = Name.

// TODO: Augment with struct types


//------------------------------------------------------------------------------
// Virtual Table - Type Info - Class Type Associations
//------------------------------------------------------------------------------

// `typeinfo of v-table` : defined in virtual-tables.logic
vtable:typeinfo[VT] = TypeInfo ->
   global_variable(VT), global_variable(TypeInfo).

// Extract class name from unmangled type info name. The latter is of
// the form: typeinfo for /CLASSNAME/
_typeinfo_class_name[TypeInfo] = ClassName <-
   typeinfo(TypeInfo),
   global_variable:unmangled_name[TypeInfo] = TIName,
   string:like(TIName, "typeinfo for %"),
   string:length[TIName] = N,
   string:substring[TIName, 13, N - 13] = ClassName.

// `typeinfo of class`
class_type:typeinfo[ClassType] = TypeInfo <-
   _typeinfo_class_name[TypeInfo] = ClassName,
   class_type:by_name[ClassName] = ClassType.


// Extract class name from unmangled vtable name. The latter is of
// the form: vtable for /CLASSNAME/
_vtable_class_name[VTable] = ClassName <-
   vtable(VTable, _),
   global_variable:unmangled_name[VTable] = UnmangledName,
   string:like(UnmangledName, "vtable for %"),
   string:length[UnmangledName] = N,
   string:substring[UnmangledName, 11, N - 11] = ClassName.

// `v-table of class`
class_type:vtable[ClassType] = VTable <-
   _vtable_class_name[VTable] = ClassName,
   class_type:by_name[ClassName] = ClassType.


//------------------------------------------------------------------------------
// Recovering Class Hierarchy
//------------------------------------------------------------------------------

primary_superclass[Type] = Supertype ->
   struct_type(Type), struct_type(Supertype).

secondary_superclass(Supertype, Type) ->
   struct_type(Type), struct_type(Supertype).


_typeinfo_class_type[TypeInfo] = ClassType <-
   class_type:typeinfo[ClassType] = TypeInfo.

primary_superclass[Type] = Supertype <-
   typeinfo:base_class[TypeInfo, 0] = BaseTypeInfo,
   _typeinfo_class_type[TypeInfo] = Type,
   _typeinfo_class_type[BaseTypeInfo] = Supertype.

secondary_superclass(Supertype, Type) <-
   typeinfo:base_class[TypeInfo, Index] = BaseTypeInfo,
   _typeinfo_class_type[TypeInfo] = Type,
   _typeinfo_class_type[BaseTypeInfo] = Supertype,
   Index > 0.


// Union of the above two kinds of superclasses

direct_superclass(Supertype, Type) <-
   primary_superclass[Type] = Supertype
 ; secondary_superclass(Supertype, Type).


// Inverse relation

direct_subclass(Subtype, Type) <-
   direct_superclass(Type, Subtype).

// Transitive closure computation to compute all superclasses of each
// type

superclass(Supertype, Type) <-
   direct_superclass(Supertype, Type).

superclass(Supertype, Type) <-
   direct_superclass(Supertype, IntermType),
   superclass(IntermType, Type).


// Constraints according to typeinfo recorded inheritance

typeinfo:baseclass(TypeInfo)
 , _typeinfo_class_type[TypeInfo] = ClassType
 ->
   !direct_superclass(_, ClassType).


typeinfo:single_inheritance(TypeInfo)
 , _typeinfo_class_type[TypeInfo] = ClassType
 , direct_superclass(Supertype1, ClassType)
 , direct_superclass(Supertype2, ClassType)
 ->
   Supertype1 = Supertype2.


//------------------------------------------------------------------------------
// Class Type Name Parsing
//------------------------------------------------------------------------------

// Class types that are template instantiations
class_type:template_instance(Type) <-
   class_type:name[Type] = FQName,
   string:like(FQName, "%<%>").

// Name without the template part

class_type:no_tpl_part[Type] = NoTplPart
 <-
   class_type:name[Type] = FQName,
   class_type:template_instance(Type),
   string:split[FQName, "<", 0] = NoTplPart.

class_type:no_tpl_part[Type] = FQName
 <-
   class_type:name[Type] = FQName,
   !class_type:template_instance(Type).


// Template part of name

class_type:tpl_part[Type] = TplPart
 <-
   class_type:name[Type] = FQName,
   class_type:template_instance(Type),
   class_type:no_tpl_part[Type] = NoTplPart,
   string:length[NoTplPart] = PrefixLength,
   string:length[FQName] = Length,
   SuffixLength = Length - PrefixLength,
   string:substring[FQName, PrefixLength, SuffixLength] = TplPart.


// Name without namespace qualifier

class_type:unqualified_name[Type] = NoTplPart
 <-
   class_type:no_tpl_part[Type] = NoTplPart,
   string:notlike(NoTplPart, "%::%").

class_type:unqualified_name[Type] = Component
 <-
   class_type:no_tpl_part[Type] = NoTplPart,
   string:split[NoTplPart, ":", _] = Component,
   string:length[Component] = N,
   N > 0,
   string:like(NoTplPart, "%::" + Component).


// Drop the LLVM version suffix (e.g., '.145')

class_type:simple_name[Type] = SimpleName
 <-
   class_type:unqualified_name[Type] = Name,
   string:split[Name, ".", 0] = SimpleName.

class_type:simple_name[Type] = Name
 <-
   class_type:unqualified_name[Type] = Name,
   string:notlike(Name, "%.%").


// Namespace

class_type:namespace[Type] = ""
 <-
   class_type:no_tpl_part[Type] = Name,
   string:notlike(Name, "%::%").

class_type:namespace[Type] = Namespace
 <-
   class_type:no_tpl_part[Type] = FQName,
   class_type:unqualified_name[Type] = Name,
   string:like(FQName, "%::%"),
   string:length[FQName] = Length,
   string:length[Name] = N,
   string:substring[FQName, 0, Length - N - 2] = Namespace.


//------------------------------------------------------------------------------
// Constructors and Destructors for objects of this class type
//------------------------------------------------------------------------------

class_type:constructor(Ctor, Type) ->
   class_type(Type), function_decl(Ctor).

class_type:destructor(Dtor, Type) ->
   class_type(Type), function_decl(Dtor).


// To identify constructors we rely on the Itanium ABI mangling rules

class_type:constructor(Ctor, Type)
 <-
   class_type(Type),
   function:name[Ctor] = FuncName,
   function:type[Ctor] = FType,
   function_type:param[FType, 0] = PtrType,
   pointer_type:component[PtrType] = Type,
   ( string:like(FuncName, "%C1%")
   ; string:like(FuncName, "%C2%")).

// Same for destructors

class_type:destructor(Dtor, Type)
 <-
   class_type(Type),
   function:name[Dtor] = FuncName,
   function:type[Dtor] = FType,
   function_type:param[FType, 0] = PtrType,
   pointer_type:component[PtrType] = Type,
   ( string:like(FuncName, "%D1%")
   ; string:like(FuncName, "%D2%")).


// Mandatory properties of class types

class_type(Type) ->
   class_type:name[Type] = _.
