// Model null as a specific memory location
constant_points_to[Constant] = NULL <-
   nullptr_constant(Constant),
   null_location[] = NULL.

// Global variable and function references is a common type of
// constants. They should be matched to the corresponding global
// allocation.

constant_points_to[Constant] = Alloc <-
   global_variable_constant:name[Constant] = Name,
   global_variable:by_name[Name] = GVar,
   global_allocation:by_variable[GVar] = Alloc.

constant_points_to[Constant] = Alloc <-
   function_constant:function_name[Constant] = FName,
   function:by_name[FName] = Func,
   global_allocation:by_function[Func] = Alloc.

constant_points_to[Constant] = Alloc <-
   constant_references_variable[Constant] = GVar,
   global_allocation:by_variable[GVar] = Alloc.

constant_points_to[Constant] = Alloc <-
   constant_references_function[Constant] = Func,
   global_allocation:by_function[Func] = Alloc.


//----------------------------------------------------------------------
// [Assignment Instructions]
//
// There are many types of instructions that essentially copy the
// points-to set of a variable to another.
//
// Cast instructions such as `bitcast` fall to this category. Often
// the returned type of a `@malloc` function call is different than
// the declared type of the target variable. The LLVM IR adds a
// temporary variable of type `i8*` to hold the result and then an
// intermediate `bitcast` instruction that casts this temporary
// variable to the right type.
//
// Another class of assignment instructions are the interprocedural
// assignments. This way we can model the implicit flow from (i) the
// actual arguments to the formal parameters, and from (ii) the return
// value of the called function to the variable that is assigned the
// result of the `call instruction`.
//----------------------------------------------------------------------

assign_instruction(InstrFunc, To, Value) ->
   function(InstrFunc), variable(To), operand(Value).

var_points_to(ACtx, Alloc, Ctx, ToVar) <-
   assign_instruction(InstrFunc, ToVar, Value),
   operand_points_to(ACtx, Alloc, Ctx, Value), // TODO: consider adding type check
   reachable_context(Ctx, InstrFunc).

// `bitcast` instructions
assign_instruction(InstrFunc, ToVar, Value) <-
   reachable_function(InstrFunc),
   bitcast_instruction:from[Instr] = Value,  // TODO: consider adding type check
   instruction:to[Instr] = ToVar,
   instruction:function[Instr] = InstrFunc.

// `ptrtoint` instructions
assign_instruction(InstrFunc, ToVar, Value) <-
   reachable_function(InstrFunc),
   ptrtoint_instruction:from[Instr] = Value,
   instruction:to[Instr] = ToVar,
   instruction:function[Instr] = InstrFunc.

// `inttoptr` instructions
var_points_to(ACtx, Unknown, Ctx, ToVar) <-
   empty_alloc_context[] = ACtx,
   unknown_location[] = Unknown,
   inttoptr_instruction(Instr),
   instruction:to[Instr] = ToVar,
   instruction:function[Instr] = InstrFunc,
   reachable_function(InstrFunc),
   reachable_context(Ctx, InstrFunc).

// `phi` instructions: treat every possible pair value as a potential
// assignment to the target variable
assign_instruction(InstrFunc, ToVar, Value) <-
   reachable_function(InstrFunc),
   phi_instruction:pair:value[Instr, _] = Value,
   instruction:to[Instr] = ToVar,
   instruction:function[Instr] = InstrFunc.


// `select` instructions; similar to `phi` instructions
assign_instruction(InstrFunc, ToVar, Value) <-
   reachable_function(InstrFunc),
   select_instruction(Instr),
   ( select_instruction:first_operand[Instr]  = Value
   ; select_instruction:second_operand[Instr] = Value ),
   instruction:to[Instr] = ToVar,
   instruction:type[Instr] = Type,
   instruction:function[Instr] = InstrFunc,
   !vector_type(Type).

// // A simple field-insensitive approach (just ignore indices of
// // `getelementptr`)
//
// assign_instruction(ToVar, Base) <-
//    getelementptr_instruction:base[Insn] = Base,
//    instruction:to[Insn] = ToVar.


// TODO: support `cmpxchg` and `atomicrmw` instructions
// TODO: support `invoke` and `landingpad` instructions


//----------------------------------------------------------------------
// [Load/Store Instructions]
//----------------------------------------------------------------------

reachable_store(InstrFunc, ToAddress, Value) ->
   function(InstrFunc), operand(Value), operand(ToAddress).

reachable_store(InstrFunc, ToAddress, Value) <-
   reachable_function(InstrFunc),
   store_instruction:value[Instr] = Value,
   store_instruction:address[Instr] = ToAddress,
   instruction:function[Instr] = InstrFunc.

_inv_reachable_store_(InstrFunc, Value, ToAddress) <-
   reachable_store(InstrFunc, ToAddress, Value).

ptr_points_to(ACtx, Alloc, BaseACtx, BaseAlloc) <-
   reachable_store(InstrFunc, ToAddress, Value),
   _inv_reachable_store_(InstrFunc, Value, ToAddress), // redundant OPT clause
   reachable_context(Ctx, InstrFunc),
   operand_points_to(ACtx, Alloc, Ctx, Value),
   operand_points_to(BaseACtx, BaseAlloc, Ctx, ToAddress),
   ptr_compatible_allocation(BaseAlloc).

reachable_load(InstrFunc, ToVar, FromAddres) ->
   function(InstrFunc), variable(ToVar), operand(FromAddres).

reachable_load(InstrFunc, ToVar, FromAddress) <-
   reachable_function(InstrFunc),
   load_instruction:address[Instr] = FromAddress,
   instruction:to[Instr] = ToVar,
   instruction:function[Instr] = InstrFunc.

var_points_to(ACtx, Alloc, Ctx, ToVar) <-
   reachable_load(InstrFunc, ToVar, FromAddress),
   reachable_context(Ctx, InstrFunc),
   operand_points_to(BaseACtx, BaseAlloc, Ctx, FromAddress),
   ptr_points_to(ACtx, Alloc, BaseACtx, BaseAlloc). // TODO: consider adding type check
