//----------------------------------------------------------------------
// [Heap and Stack Allocations]
//
// Every named variable of the original source code will have a
// corresponsing `alloca_instruction` that allocates space for it in
// the stack. Hence, we can use these instructions to track stack
// allocations.
//
// Heap allocations on the other side will be created primarily by
// calling the `@malloc` function. More heap allocation functions
// could be added in the future.
//----------------------------------------------------------------------

stack_allocation(StackAlloc),
stack_allocation:by_instruction[Insn] = StackAlloc,
var_points_to(StackAlloc, Var)
 <-
   alloca_instruction(Insn),
   instruction:to[Insn] = Var.

heap_allocation(HeapAlloc),
heap_allocation:by_instruction[Insn] = HeapAlloc,
var_points_to(HeapAlloc, Var)
 <-
   call_instruction:function[Insn] = Func,
   function:name[Func] = "@malloc",
   instruction:to[Insn] = Var.

global_allocation(Alloc),
global_allocation:by_variable[GVar] = Alloc
 <-
   global_variable(GVar).

global_allocation(Alloc),
global_allocation:by_function[Func] = Alloc
 <-
   function(Func).


// We also create allocations of functions for which we lack any
// definition, e.g., functions that belong to dynamically linked
// libraries

global_allocation(Alloc),
global_allocation:by_function[Func] = Alloc
 <-
   function_decl(Func),
   !function:definition[Func] = _.


// Model null as a specific memory location
constant:contains_alloc(Null, Constant) <-
   nullptr_constant(Constant),
   null_location[] = Null.

// TODO: model constant arrays, and constant structs

// Integers can be cast to pointers. In such case, the conservative
// approach is to assume that the pointer may point to anywhere in
// memory.
//
// Example: (int *) 0xabcd

constant:contains_alloc(Unknown, Constant) <-
   inttoptr_constant_expression(Constant),
   unknown_location[] = Unknown.


// A pointer may be masqueraded into an integer, but the associated
// memory locations are still valid.

constant:contains_alloc(Alloc, IntConstant) <-
   ptrtoint_constant_expression:from[IntConstant] = PtrConstant,
   constant:contains_alloc(Alloc, PtrConstant).

constant:contains_alloc(Alloc, OuterConstant) <-
   bitcast_constant_expression:from[OuterConstant] = InnerConstant,
   constant:contains_alloc(Alloc, InnerConstant).

// Global variable and function references is a common type of
// constants. They should be matched to the corresponding global
// allocation.

constant:contains_alloc(Alloc, Constant) <-
   global_variable_constant:name[Constant] = Name,
   global_allocation:by_variable[GVar] = Alloc,
   global_variable:by_name[Name] = GVar.

constant:contains_alloc(Alloc, Constant) <-
   function_constant:function_name[Constant] = FName,
   function:by_name[FName] = Func,
   global_allocation:by_function[Func] = Alloc.


//----------------------------------------------------------------------
// [Assignment Instructions]
//
// There are many types of instructions that essentially copy the
// points-to set of a variable to another.
//
// Cast instructions such as `bitcast` fall to this category. Often
// the returned type of a `@malloc` function call is different than
// the declared type of the target variable. The LLVM IR adds a
// temporary variable of type `i8*` to hold the result and then an
// intermediate `bitcast` instruction that casts this temporary
// variable to the right type.
//
// Another class of assignment instructions are the interprocedural
// assignments. This way we can model the implicit flow from (i) the
// actual arguments to the formal parameters, and from (ii) the return
// value of the called function to the variable that is assigned the
// result of the `call instruction`.
//----------------------------------------------------------------------

assign_instruction(To, Value) ->
   variable(To), operand(Value).

var_points_to(Alloc, ToVar) <-
   assign_instruction(ToVar, Value),
   operand_points_to(Alloc, Value).

// `bitcast` instructions
assign_instruction(ToVar, Value) <-
   bitcast_instruction:from[Insn] = Value,
   instruction:to[Insn] = ToVar.

// `ptrtoint` instructions
assign_instruction(ToVar, Value) <-
   ptrtoint_instruction:from[Insn] = Value,
   instruction:to[Insn] = ToVar.

// `inttoptr` instructions
var_points_to(Unknown, ToVar) <-
   unknown_location[] = Unknown,
   inttoptr_instruction(Insn),
   instruction:to[Insn] = ToVar.

// `phi` instructions: treat every possible pair value as a potential
// assignment to the target variable
assign_instruction(ToVar, Value) <-
   phi_instruction:pair:value[Insn, _] = Value,
   instruction:to[Insn] = ToVar.


// `select` instructions; similar to `phi` instructions
assign_instruction(ToVar, Value) <-
   select_instruction(Insn),
   ( select_instruction:first_operand[Insn]  = Value
   ; select_instruction:second_operand[Insn] = Value ),
   instruction:to[Insn] = ToVar,
   instruction:type[Insn] = Type,
   !vector_type(Type).

// `getelementptr` instructions (ignores indices)
// TODO model indices, arrays, fields, etc
// TODO model also getelementptr constant expression
assign_instruction(ToVar, Base) <-
   getelementptr_instruction:base[Insn] = Base,
   instruction:to[Insn] = ToVar.

// TODO: support `cmpxchg` and `atomicrmw` instructions
// TODO: support `invoke` and `landingpad` instructions


//---------------------------------------
//  [Interprocedural Logic]
//---------------------------------------

// Flow of actual arguments regardless of instruction type
function:actual_arg(Callee, Index, Argument) ->
   function(Callee), int[64](Index), operand(Argument).

function:actual_arg(Callee, Index, Argument) <-
   call_instruction:arg[CallInsn, Index] = Argument,
   callgraph:edge(Callee, CallInsn),
   function(Callee).

function:actual_arg(Callee, Index, Argument) <-
   invoke_instruction:arg[InvokeInsn, Index] = Argument,
   callgraph:edge(Callee, InvokeInsn),
   function(Callee).

// Identify variable arguments for variadic functions
function:va_actual_arg(Callee, Index, Argument) <-
   function:actual_arg(Callee, Index, Argument),
   function:type[Callee] = Type,
   function_type:varargs(Type),
   function_type:nparams[Type] = N,
   Index >= N.

// actual arg to formal parameter
assign_instruction(Param, Argument) <-
   function:actual_arg(Callee, Index, Argument),
   function:param[Callee, Index] = Param.

// `return` instruction to `call` instruction target
assign_instruction(ToVar, RetValue) <-
   call_instruction(CallInsn),  // do not model `invoke` instructions yet
   callgraph:edge(Callee, CallInsn),
   ret_instruction:value[RetInsn] = RetValue,
   instruction:function[RetInsn] = Callee,
   instruction:to[CallInsn] = ToVar.


// `va_arg` instruction
//
// TODO: model target-specific value `va_list` and calls to related
// LLVM intrinsic functions. Right now this may produce nothing

assign_instruction(ToVar, Argument) <-
   va_arg_instruction:type[VArgInsn] = ArgType,
   instruction:to[VArgInsn] = ToVar,
   instruction:function[VArgInsn] = Callee,
   function:va_actual_arg(Callee, _, Argument),
   operand:type[Argument] = ArgType.


// Augment call-graph by adding edges for function pointers

function:by_location[Alloc] = Callee <-
   global_allocation:by_function[Callee] = Alloc.

callgraph:edge(Callee, CallerInsn), reachable_function(Callee)
 <-
   indirect_call_instruction(CallerInsn),
   call_instruction:raw_function[CallerInsn] = Op,
   operand_points_to(Alloc, Op),
   function:by_location[Alloc] = Callee,
   function(Callee).


// The following rule augments the logic about identifying functions
// registered to run at program at exit, so that it also works with
// function pointers.

reachable_function(Callback) <-
   callgraph:edge(AtExit, Insn),
   function:name[AtExit] = "@atexit",
   call_instruction:arg[Insn, 0] = Operand,
   operand_points_to(Alloc, Operand),
   function:by_location[Alloc] = Callback.


//----------------------------------------------------------------------
// [Load/Store Instructions]
//----------------------------------------------------------------------

ptr_points_to(Alloc, BaseAlloc) <-
   store_instruction:value[Insn] = Op,
   store_instruction:address[Insn] = PtrOp,
   operand_points_to(Alloc, Op),
   operand_points_to(BaseAlloc, PtrOp).

var_points_to(Alloc, ToVar) <-
   instruction:to[Insn] = ToVar,
   load_instruction:address[Insn] = PtrOp,
   operand_points_to(BaseAlloc, PtrOp),
   ptr_points_to(Alloc, BaseAlloc).


// Intermediate relations

operand_points_to(Alloc, Operand) ->
   allocation(Alloc), operand(Operand).

operand_points_to(Alloc, VarOperand) <-
   operand:as_variable[VarOperand] = PtrVar,
   var_points_to(Alloc, PtrVar).

operand_points_to(Alloc, ConstantOperand) <-
   operand:as_constant[ConstantOperand] = ToGVar,
   constant:contains_alloc(Alloc, ToGVar).
