// Type Hierarchy under derived types

derived_type(Type)   -> type(Type).
function_type(Type)  -> derived_type(Type).
vector_type(Type)    -> derived_type(Type).
pointer_type(Type)   -> derived_type(Type).
aggregate_type(Type) -> derived_type(Type).
array_type(Type)     -> aggregate_type(Type).
struct_type(Type)    -> aggregate_type(Type).
opaque_struct_type(Type) -> struct_type(Type).

// Function Type

function_type:return[Type] = Ret -> 
   function_type(Type), type(Ret).

function_type:arg[Type, Index] = Arg -> 
   function_type(Type), int[64](Index), type(Arg).

function_type:nargs[Type] = Total -> 
   function_type(Type), int[64](Total).

// Pointer Type

pointer_type:component[Type] = Comp -> 
   pointer_type(Type), type(Comp).

pointer_type:addr_space[Type] = Addr -> 
   pointer_type(Type), int[64](Addr).

// Vector Type

vector_type:component[Type] = Comp -> 
   vector_type(Type), Type(Comp).

vector_type:size[Type] = Size ->
   vector_type(Type), int[64](Size).

vector_type:integer(Type) <-
   vector_type:component[Type] = Comp,
   integer_type(Comp).

vector_type:fp(Type) <-
   vector_type:component[Type] = Comp,
   fp_type(Comp).

vector_type:boolean(Type) <-
   vector_type:component[Type] = Comp,
   boolean_type(Comp).

vector_type:pointer(Type) <-
   vector_type:component[Type] = Comp,
   pointer_type(Comp).

// Array Type

array_type:component[Type] = Comp -> 
   array_type(Type), type(Comp).

array_type:size[Type] = Size -> 
   array_type(Type), int[64](Size).

// Struct Type

struct_type:field[Type, Index] = Field -> 
   struct_type(Type), int[64](Index), type(Field).

struct_type:nfields[Type] = Total -> 
   struct_type(Type), int[64](Total).


// Helper predicate

vector:eq_size_2(Type1, Type2) <-
   vector_type:size[Type1] = Size,
   vector_type:size[Type2] = Size.

vector:eq_size_3(Type1, Type2, Type3) <-
   vector_type:size[Type1] = Size,
   vector_type:size[Type2] = Size,
   vector_type:size[Type3] = Size.

// Two types are vector-compatible if:
//  (i)  neither is a vector, or
//  (ii) both are vectors of the same size.

vector:compatible(Type1, Type2) -> type(Type1), type(Type2).   
vector:compatible(Type1, Type2) <- 
   type(Type1), 
   type(Type2),
   !vector_type(Type1),
   !vector_type(Type2).

vector:compatible(Type1, Type2) <- 
   vector:eq_size_2(Type1, Type2).

// First Class Types

type:firstclass(Type) <-
   type(Type),
   !function_type(Type),
   !void_type[] = Type.

non_aggregate:firstclass(Type) <-
   type:firstclass(Type),
   !aggregate_type(Type).
   
pointer_type:firstclass(Type) <-
   pointer_type:component[Type] = Comp,
   type:firstclass(Comp).
