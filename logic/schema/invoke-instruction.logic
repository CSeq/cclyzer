// http://llvm.org/docs/LangRef.html#invoke-instruction
// keywords: terminator; instruction

invoke_instruction(Insn) -> instruction(Insn).

invoke_instruction:function[Insn] = Value ->
   invoke_instruction(Insn), operand(Value).

// Actual parameters
invoke_instruction:param[Insn, Index] = Param -> 
   invoke_instruction(Insn), int[64](Index), operand(Param).

invoke_instruction:calling_convention[Insn] = Con ->
   invoke_instruction(Insn), calling_convention(Con).

invoke_instruction:return_attribute[Insn] = Attr ->
   invoke_instruction(Insn), parameter_attribute(Attr).

invoke_instruction:function_attribute(Insn, Index, Attr) ->
   invoke_instruction(Insn), int[64](Index), function_attribute(Attr).

invoke_instruction:normal_label[Insn] = Normal ->
   invoke_instruction(Insn), variable(Normal).

invoke_instruction:exception_label[Insn] = Exception ->
   invoke_instruction(Insn), variable(Exception).

invoke_instruction:type[Insn] = Return <-
   invoke_instruction:function[Insn] = Value,
   operand:type[Value] = Type,
   function_type:return[Type] = Return.


// Constraints:
//
//  (1) Only ‘zeroext‘, ‘signext‘, and ‘inreg‘ attributes 
//      are valid for return values.
//  (2) The type of the invoke instruction is also the type of 
//      the return value. Functions that return no value are 
//      marked void.
//  (3) The function type shall be the signature of the pointer 
//      to function value being invoked. The argument types must 
//      match the types implied by this signature.
//  (4) All arguments must be of first class type.
//  (5) Only ‘noreturn‘, ‘nounwind‘, ‘readonly‘ and ‘readnone‘ 
//      attributes are valid as function attributes.
//  (6) The 'invoke' instruction' takes a 'normal label' and
//  (7) an 'exceptional label'.


invoke_instruction(Insn) -> invoke_instruction:function[Insn] = _.
invoke_instruction(Insn) -> invoke_instruction:normal_label[Insn] = _.
invoke_instruction(Insn) -> invoke_instruction:exceptional_label[Insn] = _.

invoke_instruction:return_attribute[_] = Attr ->
   parameter_attribute:zeroext[] = Attr;
   parameter_attribute:signext[] = Attr;
   parameter_attribute::nreg[] = Attr. // c1


invoke_instruction:type[Insn] = Type,
   !void_type[] = Type
 ->
   instruction:Type[Insn] = Type. // c2


invoke_instruction:function[Insn] = Value,
   function_type[Value] = FuncType,
   function_type:params[Type, Index] = ParamType,
   invoke_instruction:param[Insn, Index] = Param 
 ->
   operand:type[Param] = ParamType. // c3


invoke_instruction:param[_, _] = Param,
   operand:type[Param] = Typeinvoke_instruction:
 ->
   type:firstclass(Type). // c4

invoke_instruction:function_attribute(_, _, Attr) -> 
   function_attribute:noreturn[] = Attr;
   function_attribute:nounwind[] = Attr;
   function_attribute:readonly[] = Attr;
   function_attribute:readnone[] = Attr. // c5

invoke_instruction:normal_label[_] = Normal ->
   variable:label(Normal). // c6

invoke_instruction:exceptional_label[_] = Exceptional ->
   variable:label(Exceptional). // c7
